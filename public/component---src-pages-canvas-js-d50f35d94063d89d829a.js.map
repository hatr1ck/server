{"version":3,"sources":["webpack:///./src/pages/canvas.js"],"names":["Works","state","amount","init","e","ctx","refs","canvas","getContext","rotate","velocity","angle","x","Math","cos","y","sin","resolveCollision","particle","otherParticle","xVelocityDiff","yVelocityDiff","xDist","yDist","color","random","atan2","m1","mass","m2","u1","u2","v1","v2","vFinal1","vFinal2","Circle","radius","this","friction","draw","beginPath","fillStyle","arc","PI","fill","update","arr","window","innerWidth","innerHeight","i","length","distance","floor","round","x1","y1","x2","y2","sqrt","pow","j","push","animation","requestAnimationFrame","clearRect","onAmountChange","index","value","setState","onColorChange","componentDidMount","width","height","render","style","background","ref","Component"],"mappings":"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","file":"component---src-pages-canvas-js-d50f35d94063d89d829a.js","sourcesContent":["import React, { Component } from 'react';\r\nimport Menu from '../components/header'\r\n\r\nclass Works extends Component {\r\n    state = {\r\n        amount: 30\r\n    }\r\n\r\n    componentDidMount() {\r\n        this.ctx = this.refs.canvas.getContext('2d');\r\n        this.init()\r\n        this.refs.canvas.width = window.innerWidth;\r\n        this.refs.canvas.height = window.innerHeight/ 100 * 98;\r\n        // window.addEventListener('resize', function risiz(){\r\n        // this.setState({\r\n        //     wind:window.innerWidth / 100 * 84\r\n        // })\r\n    // })\r\n    }\r\n    // componentWillUnmount() {\r\n    //     window.removeEventListener('resize', this.risiz);\r\n    // }\r\n    // resiz = () => {\r\n    //     this.refs.canvas.width = window.innerWidth / 100 * 84;\r\n    //     this.refs.canvas.height = window.innerHeight;\r\n    // }\r\n\r\n    init = (e) => {\r\n        let ctx = this.refs.canvas.getContext('2d');\r\n        // let .0 = {\r\n        //     x: 0,\r\n        //     y: 0\r\n        // }\r\n        // this.refs.canvas.addEventListener('mousemove', (e) => {\r\n\r\n        //     mouse.x = e.clientX - this.refs.canvas.getBoundingClientRect().left;\r\n        //     mouse.y = e.clientY - this.refs.canvas.getBoundingClientRect().top;\r\n        // })\r\n\r\n        function rotate(velocity, angle) {\r\n            const rotatedVelocities = {\r\n                x: velocity.x * Math.cos(angle) - velocity.y * Math.sin(angle),\r\n                y: velocity.x * Math.sin(angle) + velocity.y * Math.cos(angle)\r\n            };\r\n\r\n            return rotatedVelocities;\r\n        }\r\n\r\n        function resolveCollision(particle, otherParticle) {\r\n            const xVelocityDiff = particle.velocity.x - otherParticle.velocity.x;\r\n            const yVelocityDiff = particle.velocity.y - otherParticle.velocity.y;\r\n            const xDist = otherParticle.x - particle.x;\r\n            const yDist = otherParticle.y - particle.y;\r\n            particle.color = 'rgba(' + Math.random() * 255 + ',' + Math.random() * 255 + ',' + Math.random() * 255 + ',' + Math.random() + ')';\r\n            otherParticle.color = 'rgba(' + Math.random() * 255 + ',' + Math.random() * 255 + ',' + Math.random() * 255 + ',' + Math.random() + ')';\r\n            // Prevent accidental overlap of particles\r\n            if (xVelocityDiff * xDist + yVelocityDiff * yDist >= 0) {\r\n\r\n                // Grab angle between the two colliding particles\r\n                const angle = -Math.atan2(otherParticle.y - particle.y, otherParticle.x - particle.x);\r\n\r\n                // Store mass in var for better readability in collision equation\r\n                const m1 = particle.mass;\r\n                const m2 = otherParticle.mass;\r\n\r\n                // Velocity before equation\r\n                const u1 = rotate(particle.velocity, angle);\r\n                const u2 = rotate(otherParticle.velocity, angle);\r\n\r\n                // Velocity after 1d collision equation\r\n                const v1 = { x: u1.x * (m1 - m2) / (m1 + m2) + u2.x * 2 * m2 / (m1 + m2), y: u1.y };\r\n                const v2 = { x: u2.x * (m1 - m2) / (m1 + m2) + u1.x * 2 * m2 / (m1 + m2), y: u2.y };\r\n\r\n                // Final velocity after rotating axis back to original location\r\n                const vFinal1 = rotate(v1, -angle);\r\n                const vFinal2 = rotate(v2, -angle);\r\n\r\n                // Swap particle velocities for realistic bounce effect\r\n                particle.velocity.x = vFinal1.x;\r\n                particle.velocity.y = vFinal1.y;\r\n\r\n                otherParticle.velocity.x = vFinal2.x;\r\n                otherParticle.velocity.y = vFinal2.y;\r\n            }\r\n        }\r\n\r\n\r\n\r\n        function Circle(x, y, radius) {\r\n            this.x = x;\r\n            this.y = y;\r\n            this.velocity = {\r\n                x: (Math.random() - 0.5) * 3,\r\n                y: (Math.random() - 0.5) * 3\r\n            }\r\n            this.radius = radius;\r\n            this.friction = 0.4;\r\n            this.mass = 1;\r\n            this.color = 'rgba(' + Math.random() * 255 + ',' + Math.random() * 255 + ',' + Math.random() * 255 + ',' + Math.random() + ')';\r\n\r\n            this.draw = () => {\r\n                ctx.beginPath()\r\n                ctx.fillStyle = this.color;\r\n                ctx.arc(this.x, this.y, this.radius, Math.PI * 2, false)\r\n                ctx.fill();\r\n            }\r\n\r\n            this.update = (arr) => {\r\n                this.x += this.velocity.x;\r\n                this.y += this.velocity.y;\r\n\r\n                //  bounce from the sides\r\n                if (this.x + this.radius + this.velocity.x > window.innerWidth / 100 * 98 || this.x - this.radius < 0) {\r\n                    this.velocity.x = -this.velocity.x;\r\n                }\r\n\r\n                // bounce from the top/bottom\r\n                if (this.y + this.radius + this.velocity.y > window.innerHeight/ 100 * 98 || this.y - this.radius < 0) {\r\n                    this.velocity.y = -this.velocity.y;\r\n                } else {\r\n                    //this.velocity.y += 1;            //gravity\r\n                }\r\n                //collision\r\n                for (let i = 0; i < arr.length; i++) {\r\n                    if (this === arr[i]) {\r\n                        continue;\r\n                    }\r\n                    if (distance(this.x, this.y, arr[i].x, arr[i].y) - this.radius * 2 < 0) {\r\n\r\n                        resolveCollision(this, arr[i])\r\n\r\n                    }\r\n                }\r\n\r\n                //hover effect\r\n                // if (this.radius < 50 && mouse.x - this.x < 50 && mouse.x - this.x > -50 && mouse.y - this.y < 50 && mouse.y - this.y > -50) {\r\n                //     this.color = 'rgba(' + Math.random() * 255 + ',' + Math.random() * 255 + ',' + Math.random() * 255 + ',' + Math.random() + ')';\r\n                // }\r\n                // else if(this.radius >100){\r\n                //   this.radius-=1;\r\n                // }\r\n\r\n                //slows down the ball if it fall on the ground\r\n                if (Math.floor(this.y) === Math.floor(window.innerHeight / 100 * 98 - this.radius)) {\r\n                    if (Math.round(this.velocity.x) === 0) {\r\n                        this.velocity.x = 0;\r\n                    }\r\n                    if (this.velocity.x > 0) {\r\n                        this.velocity.x -= 0.1;\r\n                    } else if (this.velocity.x < 0) {\r\n                        this.velocity.x += 0.1;\r\n                    }\r\n                }\r\n                this.draw()\r\n            }\r\n        }\r\n        let arr = [];\r\n\r\n        function distance(x1, y1, x2, y2) {\r\n            let xDist = x2 - x1;\r\n            let yDist = y2 - y1;\r\n            return Math.sqrt(Math.pow(xDist, 2) + Math.pow(yDist, 2));\r\n        }\r\n\r\n\r\n        for (let i = 0; i < this.state.amount; i++) {\r\n            let radius = 30;\r\n            let x = Math.random() * ((window.innerWidth / 100 * 98 - radius) - (radius * 2)) + (radius * 2); //Math.random() * (10 - 9) + 9\r\n            let y = Math.random() * ((window.innerHeight/ 100 * 98 - radius) - (radius * 2)) + (radius * 2);\r\n            if (i !== 0) {\r\n                for (let j = 0; j < arr.length; j++) {\r\n                    if (distance(x, y, arr[j].x, arr[j].y) - radius * 2 < 0) {\r\n                        x = Math.random() * ((window.innerWidth / 100 * 98 - radius) - (radius * 2)) + (radius * 2); //Math.random() * (10 - 9) + 9\r\n                        y = Math.random() * ((window.innerHeight / 100 * 98- radius) - (radius * 2)) + (radius * 2);\r\n                        j = -1;\r\n                    }\r\n                }\r\n            }\r\n            arr.push(new Circle(x, y, radius));\r\n        }\r\n        let animation = () => {\r\n            requestAnimationFrame(animation);\r\n            this.ctx.clearRect(0, 0, window.innerWidth / 100 * 98, window.innerHeight/ 100 * 98)\r\n            for (let i = 0; i < arr.length; i++) {\r\n                arr[i].update(arr)\r\n            }\r\n        }\r\n        animation()\r\n    }\r\n\r\n\r\n    onAmountChange = (e, index, value) => {\r\n        this.setState({ amount: value }, () => this.init());\r\n    }\r\n    onColorChange = (e, index, value) => {\r\n        this.setState({ color: value });\r\n    }\r\n    render() {\r\n        return (\r\n            <div style={{background:'white', height:'100vh'}}>\r\n            <Menu />\r\n              <canvas ref=\"canvas\" />\r\n            </div>\r\n\r\n\r\n        );\r\n    }\r\n}\r\n\r\nexport default Works;\r\n"],"sourceRoot":""}